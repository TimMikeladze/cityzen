<!DOCTYPE html>
<html>
<head>
<style>
body { margin: 0; overflow: hidden; }
canvas { background-color: #99ddaa; }
</style>
<script type="text/javascript">
window.onload = () => {
  'use strict'

  var _canvas = document.getElementById('canvas')
  var _context = _canvas.getContext('2d')
  var _dragEndX
  var _dragEndY
  var _dragStartX
  var _dragStartY
  var _isDragging = false
  var _isRotating = false
  var _rotation = 0
  var _rotationStart
  var _rotationStartX
  var _rotationStartY

  var _clearCanvas = () => {
    _canvas.width = _canvas.width
  }

  var _distance = (startX, startY, endX, endY) => {
    var diffX = Math.abs(startX - endX)
    var diffY = Math.abs(startY - endY)
    var distance = Math.sqrt(diffX * diffX + diffY * diffY)
    return distance
  }

  var _dimensions = () => {
    var x, y
    var z = _distance(_dragStartX, _dragStartY, _dragEndX, _dragEndY)
    var d = _dragEndX - _dragStartX
    var theta = Math.acos(d / z)
    if (_dragEndY > _dragStartY) {
      var phi = theta - _rotation
      x = z * Math.cos(phi)
      y = z * Math.sin(phi)
    } else {
      var phi = theta + _rotation
      x = z * Math.cos(phi)
      y = -z * Math.sin(phi)
    }
    return {x:x,y:y}
  }

  var _start = () => {
    var d = _distance(0, 0, _dragStartX, _dragStartY)
    var theta = Math.PI / 2 - _rotation / 2
    var z = 2 * d * Math.cos(theta)
    var phi = Math.PI - theta - Math.acos(_dragStartX / d)
    var x = _dragStartX + z * Math.cos(phi)
    var y = _dragStartY - z * Math.sin(phi)
    return {x:x,y:y}
  }


  /* Initialization */

  _canvas.height = window.innerHeight
  _canvas.width = window.innerWidth


  /* Event bindings */

  _canvas.addEventListener('mousedown', (event) => {
    _dragStartX = event.x
    _dragStartY = event.y
    _isDragging = true

    // Draw the anchor
    _clearCanvas()
    _context.beginPath()
    _context.fillStyle = 'rgba(20,200,80,0.5)'
    _context.arc(event.x, event.y, 10, 0, 2 * Math.PI)
    _context.fill()
  })

  _canvas.addEventListener('mousemove', (event) => {

    if (_isDragging) {
      _dragEndX = event.x
      _dragEndY = event.y
      if (_isRotating) {
        var rotationStartToCursor = _distance(_rotationStartX, _rotationStartY, event.x, event.y)
        var anchorToRotationStart = _distance(_dragStartX, _dragStartY, _rotationStartX, _rotationStartY)
        var anchorToCursor = _distance(_dragStartX, _dragStartY, event.x, event.y)
        var rotationDelta =
          Math.acos(
            (anchorToCursor * anchorToCursor +
             anchorToRotationStart * anchorToRotationStart -
             rotationStartToCursor * rotationStartToCursor) /
            (2 * anchorToCursor * anchorToRotationStart)
          )
        var orientation = Math.sign((_rotationStartX - _dragStartX) * (event.y - _dragStartY) - (_rotationStartY - _dragStartY) * (event.x - _dragStartX))
        _rotation = _rotationStart + rotationDelta * orientation
      }
    }

    // Draw the rotated rectangle
    _clearCanvas()
    _context.save()
    _context.rotate(_rotation)
    _context.fillStyle = 'rgba(100,100,100,0.5)'
    var start = _start()
    var dimensions = _dimensions()
    _context.fillRect(start.x, start.y, dimensions.x, dimensions.y)

    // Draw the anchor
    _context.restore()
    _context.beginPath()
    _context.fillStyle = _isDragging ? 'rgba(20,200,80,0.5)' : 'rgba(0,80,250,0.3)'
    _context.arc(event.x, event.y, 10, 0, 2 * Math.PI)
    _context.fill()
  })

  _canvas.addEventListener('mouseup', (event) => {
    _isDragging = false
    _dragEndX = undefined
    _dragEndY = undefined
    _rotation = 0
  })

  window.addEventListener('keydown', (event) => {
    if (event.ctrlKey) {
      _rotationStart = _rotation
      _rotationStartX = _dragEndX
      _rotationStartY = _dragEndY
      _isRotating = true
    }
  })

  window.addEventListener('keyup', (event) => {
    _isRotating = false
  })

}
</script>  
</head>
<body>
<canvas id="canvas">
</canvas>  
</body>
</html>